---
export interface Props {
  contentSections: any[];
  propName?: string;
  editable?: boolean;
}

const components: Record<string, Function> = {};
const componentImports = import.meta.glob("../**/*.{jsx,astro}", {
  eager: true,
});

function pascalToKebab(pascal: string): string {
  return pascal
    .replace(/([A-Z])/g, "-$1")
    .toLowerCase()
    .replace(/^-/, "");
}

Object.entries(componentImports).forEach(([path, obj]) => {
  const parts = path.replace("../", "").split(".")[0].split("/");
  const filename = parts[parts.length - 1];

  const kebabFilename = pascalToKebab(filename);

  if (parts.length > 1 && kebabFilename === parts[parts.length - 2]) {
    parts.pop();
    parts[parts.length - 1] = kebabFilename;
  } else {
    parts[parts.length - 1] = kebabFilename;
  }

  const componentName = parts.join("/");

  components[componentName] = (obj as any).default;
});

const { contentSections, editable = true } = Astro.props;
---

{
  // Array-level editable attributes are owned by the caller's container element.
  // This utility only resolves blocks and marks each rendered block as an array item.
  contentSections?.map((block) => {
    const Component = components[block._component];

    if (!Component && block._component) {
      console.warn(
        `Component not found: ${block._component}. Available components:`,
        Object.keys(components)
      );
    }

    return Component ? (
      <Component
        data-editable={editable ? "array-item" : undefined}
        {...block}
        editable={editable}
      />
    ) : null;
  })
}
